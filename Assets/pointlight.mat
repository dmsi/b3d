name: point_light
.VS: &VS_normal | 
  #version 330 core

  layout(location = 0) in vec3 IN_position;
  layout(location = 1) in vec3 IN_normal;
  layout(location = 3) in vec2 IN_uv;

  out InOut {
    vec3 wpos;
    vec3 wnrm;
    vec2 uv;
  } OUT;

  uniform mat4 SU_PVM_MATRIX; //SU_pvm_matrix? ->IN, OUT, SU (Standard or System Uniform)
  uniform mat4 SU_M_MATRIX;


  void main() {
    OUT.wnrm = normalize(SU_M_MATRIX * vec4(IN_normal, 0)).xyz;
    OUT.wpos = (SU_M_MATRIX * vec4(IN_position, 1)).xyz;
    OUT.uv = IN_uv;
    gl_Position = SU_PVM_MATRIX * vec4(IN_position, 1); 
  }

.FS: &FS_normal | 
  #version 330 core

  in InOut {
    vec3 wpos;
    vec3 wnrm;
    vec2 uv;
  } IN;

  out vec4 OUT_color;

  struct PtLight {
    vec3 position;
    vec3 attenuation; // x + y*d + z*d*d, d - distance
    vec4 color;
  };

  uniform samplerCube TEXTURE_0; // depth cubemap

  uniform PtLight light = PtLight (
      vec3(0, 0, 0),
      vec3(1, .1, 0),
      vec4(1, 1, 1, 1)
  );

  float ToLinearDepth(float z_depth, float near, float far) {
    //return 2.0 * near * far / (far + near - (2.0 * z_depth - 1.0) * (far - near));
    return 2.0 * near * far / (far + near - (z_depth) * (far - near));
  }
  
  // https://stackoverflow.com/questions/10786951/omnidirectional-shadow-mapping-with-depth-cubemap
  // it explains why i should go for FromLight vector to distance convertion instead of unpacking 
  // cubemap z to distance. 
  float VectorToDepthValue(vec3 Vec, float n, float f) {
    vec3 AbsVec = abs(Vec);
    float LocalZcomp = max(AbsVec.x, max(AbsVec.y, AbsVec.z));
    //const float f = 2048.0;
    //const float n = 1.0;
    float NormZComp = (f+n) / (f-n) - (2*f*n)/(f-n)/LocalZcomp;
    return (NormZComp + 1.0) * 0.5;
  }

  void main () {
    vec2 uv = vec2(IN.uv.x, 1-IN.uv.y);
    vec3 n = normalize(IN.wnrm);

    vec3 from_light = light.position - IN.wpos;
    float light_dist = length(from_light);


    vec3 l = normalize(from_light);
    float att = dot(vec3(light.attenuation), vec3(1, light_dist, light_dist*light_dist));
    

    float nearest_z = texture(TEXTURE_0, -l).r;
    // far and near of shadowcube camera
    float near = .1, far = 100;
    float nearest = ToLinearDepth(nearest_z, near, far);

    float ld = VectorToDepthValue(from_light, near, far); 


    float shadow = 1;
    float bias = 0.0000;
    if (ld - bias > nearest_z) {
    //if (light_dist - bias > nearest) {
      //shadow = 1.0 - 0.2;
      shadow = 1 - 0.15;
    }
    
    float ambient = .3;
    float diffuse = max(dot(n, l), ambient) / att;
    if (dot(n, l) > 0) {
      diffuse *= shadow;
    }

    //float d = length(light.position - IN.wpos);
    //vec3 l = normalize(light.position - IN.wpos);
    //float att = dot(vec3(light.attenuation), vec3(1, d, d*d));
    //float diffuse = max(dot(n, l), .3) / att;
    //float diffuse = 1.0 / att;
    //OUT_color = vec4(abs(n.xyz)/2, 1) * diffuse;
    vec4 tint = vec4(.8, .4, .4, 1);
    OUT_color = vec4(vec3(diffuse), 1) * tint;

    //OUT_color.rgb = vec3(shadow);
  }

.VS: &VS_shadowcast |
  #version 330 core
  layout(location = 0) in vec3 IN_position;

  uniform mat4 SU_PVM_MATRIX;

  void main() {
    gl_Position = SU_PVM_MATRIX * vec4(IN_position, 1); 
  }

.FS: &FS_shadowcast |
  #version 330 core

  out vec4 OUT_color;

  void main () {
    // just need to fill the depth buffer
    OUT_color = vec4(gl_FragCoord.z, 0, 0, 1); 
  }

pass:
  name     : pass.normal
  queue    : 110
  tags     : [onscreen]
  cull     : ccw
  vertex   : *VS_normal
  fragment : *FS_normal

pass:
  name     : pass.shadowcast
  tags     : [shadow-caster]
  queue    : 100
  cull     : cw
  vertex   : *VS_shadowcast
  fragment : *FS_shadowcast
